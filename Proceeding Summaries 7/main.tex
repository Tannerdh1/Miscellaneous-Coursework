\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{biblatex}
\title{Proceeding Summaries 7}
\author{Tanner Hammond}
\date{February 2021}
\addbibresource{references.bib}
\begin{document}

\maketitle

\section{How Effective Are Smart Contract Analysis Tools? Evaluating Smart Contract Static Analysis Tools using Bug Injection \cite{Ghaleb}}

Bugs in smart contracts are constantly being exploited by malicious attacks for financial gains. Also, transactions on Ethereum are immutable and cannot be reverted and it's difficult to update a smart contract after it's deployed. Several static analysis tools have been developed to find security bugs, but of course bugs are still a big issue. This brings their efficiency into question and is further question due to the limited evaluation. A lot of the tools are only tested by their developers on custom data sets and inputs or on data sets of contracts with a limited number of bugs. Typically these tools also have false-positives and negatives, false-negatives in particular being a critical issue. There are also studies that have found many of the defects can be detected by static analysis in theory, but aren't detected due to limitations of the tools. This paper performed bug injections to evaluate the false-negatives of smart contract static analysis tools. There have been few papers on bug injection with smart contracts, because it can be challenging. Smart contracts are written using Solidity, which differs from typical languages targeted by mutation testing tools and also since the goal is to inject security bug, the bugs injected should lead to exploitable vulnerabilities. This paper proposes SolidiFI for systemic evaluation of smart contract static analysis tools. SolidiFI injects bugs formulated as code snippets into all possible locations into a smart contract's source code written in Solidity. It takes about one minute for SolidiFI to inject bugs into a smart contract.The code snippets are vulnerable to specific security vulnerabilities that can be exploited.The smart contracts are then analyzed using the tool being evaluated and the results are inspected for injected bugs that are not identified. They used SolidiFI to evaluate six tools for false-positives and negatives. The result of SolidiFi on 50 contracts show that all of the tools had false-negatives ranging from 129 to 4137 bugs across 7 different bug types despite claims from the tools to be able to detect such bugs. These results can help tool developers to improve their tool and also to propose new tools and methods. 

\section{A Personal Data Determination Method Based On Blockchain Technology and Smart Contract \cite{Wang}}

During the practice of promoting the open sharing of data resources, the primary problem to be solved is how to confirm the related right about the data. The core of data determination is to determine the right holder of the data, which is the one who owns it and who can use it and how to transfer the data ownership. Determination of personal data can help solve issues like copyright problems, data application problems, and data storage problems. Digital contents are pirated frequently due to how easy it is to copy, modify, and spread. Blockchain is highly compatible with clear data attribution and the access record is visible. This paper presents a personal data determination method based on blockchain and intelligent contracts. It generates identity certificates overcoming the disadvantages of blockchain anonymization, uses hash algorithms to hash data and uses the identity certificates to sign the ownership. This prevents things to be tampered with and secures the owner while allows transfers of ownership. All of this guarantees authenticity of data, confirmation of data, and promotes the open sharing of data.

\section{Securing Smart Contract with Runtime Validation \cite{Li}}

Errors inside smart contracts are sever due to them being immutable, they store and manage critical information, and errors are treated as intended behavior and faithfully executed by blockchain systems. To help secure smart contracts, we have analysis tools and verifying the consistency between implementation and specification. Automated verification tools relying on theorem provers typically have narrow scopes and may fail to explore the verification search space and mechanical verification requires human intervention and are too expensive to apply in practice. This paper argues using runtime validation would be effective and efficient. With access to runtime information, runtime validation techniques can be fully automated and can typically achieve much higher coverage than typical static analysis. Runtime validation for traditional programs has excessive performance overhead, but from their observation Proof-of-Work consensus is the main performance bottleneck for blockchain systems. They hypothesize that the overhead of runtime validation is negligible for smart contracts. They designed Solythesis, a runtime validation tool, to validate the hypothesis. Solythesis works as a source to source Solidity compiler and detects errors at runtime. The instrumented contract is guaranteed to nullify all transactions that cause the contract to violate the specified invariants. The design of Solythesis is based on the bottleneck by the storage layer. They design the instrumentation algorithm to minimize the number of blockchain state access. One challenge for Solythesis is how to efficiently enforce invariants for ledger-like data structure in smart contracts. For this challenge, Solythesis uses a combination of delta update and delta check techniques. It analyzes the source code of each contract function to determine the set of state values that could be modified and the constraints that could be violated during a transaction. It then instruments the instructions to maintain the potentially changed values and check the potentially violated constraints. These techniques allow Solythesis to generate secure contracts with negligible overhead. Their experimental results show that Solythesis prevent vulnerable contracts from violating defined invariants. It also shows negligible instrumentation overhead with 0.1\% CPU usage and 3.2KB/s disk write overhead.

\section{Next 3 Papers}
\item Behavioral simulation for smart contracts
\item Inheritance software metrics on smart contracts
\item LATTE: Visual Construction of Smart Contracts

\printbibliography

\end{document}
