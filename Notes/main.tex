\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{biblatex}
\addbibresource{references.bib}
\title{Notes}
\author{Tanner Hammond}
\date{March 2021}

\begin{document}

\maketitle

\section{Static Analysis of Integer Overflow of Smart Contracts in Ethereum \cite{Static}}

\subsection{Section 2: The Characteristics of Integer Overflow for Solidity Smart Contracts in Ethereum}
Integer data type of the Ethereum Smart Contract has a fixed size and its step size is incremented by 8 bits, i.e. int8 to int256. Each integer type has a range and if it's exceed it will cause an overflow. Types of integer overflow are divided into multiplication, addition, and subtraction. Multiplication overflow is caused by a multiplication operator without checking whether the multiplication operation is out of range. The types are summarized in my write up. Addition is the same thing but with addition operation, these types are also described in my write up. Same thing with subtraction. Integer overflow features of smart contracts include one of these operators and integer variables. The integer variables can be manipulated manually such as parameters and there are typically no statements that check if their operations are out of range.

\subsection{Section 3: Static Analysis of Integer Overflow in Smart Contracts}
They abstractly define XPath patterns for the 11 types of integer overflow that were described. They designed an optimized and extensible static detection tool for integer overflow of Solidity smart contracts based on the idea of SmartCheck and using the XPath patterns. The main architecture of the tool is divided into three modules; ANTLRV4, matching detector, and XPath patterns. They define the XPath patterns abstractly based on vulnerability characteristics to form a rule library.The user detects sources codes of the smart contract, the tool performs lexical analysis and syntax analysis on the source codes and generates abstract syntax tree ,and then converts into the XML based intermediate representation. The XPath expression is extracted by traversing the rule library to locate the matching nodes in the XML based intermediate representation. The numbers of rows in the source codes are relocated to form the vulnerability analysis report.

ANTLRV4 is a grammar analysis generator based on LL(*) grammar that generates lexical analysis programs and syntax analysis programs through user-defined grammar rules. It can also generate abstract syntax trees and intermediate representations. 

Matching Detector uses custom XPath patterns to detect integer overflow vulnerabilities in smart contracts. When detected, the source codes are converted to XML based intermediate representation. Each rule is traversed in the rule library and the XPath expression is extracted in each rule. Each XPath expression is executed to query and locates the matching nodes in the XML based intermediate representation. If the matching node is detected, it is put in the temporary storage area. Then the storage area is traversed, the vulnerability information of the matching nodes is obtained, and line numbers are returned to form a vulnerability report. 

The rule library contains a number of rules and each one includes XPath patterns. Each rule is a Rule node which contains a child RuleID node and another child Patterns node. Each child Patterns node contains a plurality of child Pattern nodes. Each Pattern node contains the attribute patternID node, the child Categories node that represents language type, the child Severity node that represents risk level, and the child XPath node. The integer overflow corresponds to three Rule nodes. The three overflow types can be distinguished by the RuleID node. There are 12 XPath patterns of multiplication overflow, 38 for addition, and 33 for subtraction. Each XPath pattern corresponds to a Pattern node and a different patternID node. The patternID in this paper is a six character string consisting of overflow type and number like add101, add102, etc. When a smart contract is detected, the expression in the XPath node is extracted to implement vulnerability detection. Their GitHub has the XPath patterns, rule library, test samples, and more. The paper then shows a visual of what happens when the XPath pattern with patternID as sub102 is selected. It shows the features, the syntax tree, shows what testing the XPath expression with XMLSpy2013 looks, and the XPath patterns of sub102.

\subsection{Section 4: Experiment Results}

The tool they use is a command line tool. The environment they used it in is; Intel i7-7500 CPU, 16GB of
memory, maven, JDK 1.8, ANTLR 4.7. They used a JSoup crawler to crawl 2,500 source codes of smart contracts as data sets on Etherscan. They also crawled 1500 validated sources codes from Ropsten, Kovan, and Rinkeby. They used the source code of 7,000 smart contracts with different contract addresses to evaluate their tool. Then to improve the accuracy of detection and reduce the false positive and negatives, they optimized the XPath patterns based on the analysis of the detection results. They optimized and improved the XPath patterns multiple times through evaluation to get the best accuracy they can. There still may be unknown forms of integer overflow types, so false negatives can happen. With the 7,000 source codes they scanned, 109 had multiplication overflow, 218 addition, and 103 subtraction. This indicated that there are still integer overflow vulnerabilities in verified smart contracts. They also compared their tool to others, but most tools can't detect integer overflow vulnerabilities. Some of these are SmartCheck, Securify, and Oyente. VaaS can detect some, but it can't detect for simple smart contracts and isn't suitable for mass detection. The final number of 430 detections were after the optimization, so it doesn't have false positives like before the optimization. They also show examples of the core code of false positives cases.

\section{Securify: Practical Security Analysis of Smart Contracts \cite{Securify}}

\subsection{Section 1: Introduction}

Main challenge for creating an effective security analyzer for smart contracts is the Turing completeness of the programming language, which renders automated verification of arbitrary properties undecidable. Current systems rely on fairly generic testing and symbolic execution methods, like Oyente and Mythril. These have drawbacks like missing critical violations due to under-approximation, produces false positives due to imprecise modeling of domain-specific elements, and fails to achieve sufficient code coverage on realistic contracts. These place a burden on users since they must inspect all reports of false alarms and worry about unreported vulnerabilities. A viable path to addressing these challenges is building an automated verifier that targets important domain-specific properties.

It is often possible to devise precise patterns expressed on the contract's data-flow graph in a way where a match of the pattern implies a violation or satisfaction of the original security property. 90.9\% of Ethereum smart contracts can be proved free of the DAO bug by matching a pattern string that calls are not followed by writes to storage. Violations of the original property in real-world contracts tend to violate a much simpler property. Key benefit in working with patters is that patterns are substantially more amenable to automated reasoning.

Securify is a lightweight and scalable security verifier. Key idea is to define two kinds of patterns that mirror a given security property; compliance patterns, which imply the satisfaction of the property and violations patterns, which imply its negation. Securify symbolically encodes the dependence graph of the contract in stratified Datalog solvers to analyze the code. Patterns are expressed in a designated domain-specific language (DSL). Starting with the contract's bytecode, Securify derives semantic facts inferred by analyzing the contract's dependency graph and uses these facts to check a set of compliance and violation patterns. Securify classes contract behaviors into violations, warnings, and compliant. 

Securify reduces the required effort to inspect reports in two ways. Existing analyzers do not report definite violations and thus require users to manually classify all reported vulnerabilities into true positives and false positives. Securify automatically classifies behaviors guaranteed to be violations and the user only needs to manually classify the warning as true or false positives. The evaluation shows the approach of using both violation and compliance patterns reduces the warnings a user needs to inspect manually between 65.9\% to 99.4\% depending on the properties. Existing analyzers fail to report unsafe behaviors, sometimes up to 72.9\%, meaning users may have to manually inspect portions of the code that are not covered by the analyzer. Securify reports all unsafe behaviors.

Securify has been used to perform detailed commercial audits of smart contracts, iteratively improving the approach and adding more patterns. The design and implementation of Securify has benefited from the experience. Their approach has been to run all available tools and then to manually inspect the reported vulnerabilities so to assess their severity. Different tools support things differently, so Securify covers a number of important properties while symbolic execution tools cover numerical properties. Securify is helpful in auditing large contracts.

The main contributions are:

\begin{enumerate}
    \item A decompiler that symbolically encodes the dependency graph of Ethereum contracts in datalog. (Section 4)
    \item A set of compliance and violation security patterns that capture sufficient conditions to prove and disprove practical security properties. (Section 5)
    \item An end-to-end implementation which fully automates the analysis of contracts. (Section 6)
    \item An extensive evaluation over existing Ethereum smart contracts showing that Securify can effectively prove the correctness of contracts and discover violations. (Section 7)
\end{enumerate}

\subsection{Section 3: The Securify System}

The input to Securify is the EVM bytecode of a contract and a set of security patterns, specified in the designated DSL. It can also take contracts written in Solidity which are compiled to EVM bytecode. There are three steps; Decompiling EVM bytecode, inferring semantic facts, and checking security patterns. Securify first transforms the EVM bytecode provided as input into a stackless representation in static-single assignment form and identifies methods. 

After decompilation, Securify performs partial evaluation to resolve memory and storage offsets, jump destinations, all of which are important for analyzing the code statically. After decompilation, Securify analyzes the contract to infer semantic facts, including data and control flow dependencies. Securify's derivation of semantic facts is specified declaratively in stratified Datalog and is fully automated using scalable engines. Key benefits of the declarative approach are: inference rules concisely capture abstract reasoning about different components, more facts and inference rules can be easily added, and inference rules are specified in a modular way. 

After obtaining the semantic facts, Securify checks the set of compliance and violate security patterns, given as input. Since they are written in a specialized DSL, it enables security experts to extend the built-in set of patterns with their customized patterns. Their DSL is a fragment of logical formulas over the semantic facts inferred by Securify. Securify's DSL is important for extensibility: adding new security patterns amounts to specifying them in the DSL. Contract-specific patterns are sometimes added by security experts while conducting security audits. For example, it is often required to check for the absence of undesirable dependencies such as: only the owner can modify certain values in the storage or to ensure that the result of a specific arithmetic expression does not depend on the division instruction. 

For any match of a violation pattern, Securify outputs the the instruction that caused the pattern to match. The offset of the instruction can be easily mapped to its corresponding line in the solidity code if the source code is provided. For any property for which neither the violation nor the compliance pattern is matched, Securify outputs a warning indicating that it failed to prove or disprove the property. Securify has a couple of limitations that the version of Securify talked about in the paper. That version can't reason about numerical properties such as overflow. To address the limitation, they plan to extend Securify with numerical analysis using ELINA (ETH Library for Numerical Analysis), which would not only improve the precision of Securify but enable the check of numerical properties. Second, Securify does not reason about reachability and assumes that all instructions in the contract are reachable. The assumption is necessary to establish a formal correspondence between the security properties supported by Securify and the patterns used to prove and disprove them. Finally, the properties they consider capture violations that can often be exploited by attackers. To address this, security experts can write contract-specific patterns in Securify's DSL.

\subsection{Section 4: Semantic Facts}

This section is about the automated inference of control and data flow dependencies of Securify. The facts inferred in this process are called semantic facts and are used for checking security properties. First things talked about are the background of the EVM instruction set and stratified Datalog.

The EVM is the Ethereum Virtual Machine.The EVM instruction set (over which contracts are written) supports a few dozen opcodes. Securify handles all EVM opcodes. Many of the opcodes are eliminated when Securify decompiles the EVM bytecode to it stackless representation. The relevant instructions are:
\begin{enumerate}
    \item Arithmetic operations and comparison like add, mul. The paper uses op to denote these operations.
    \item Cryptographic has functions like sha3.
    \item Environmental information like balance that returns the balance of a contract, caller is the identity of the transaction sender, callvalue is the amount of ether specified to be transferred by the transaction.
    \item Block information like number, timestamp, gaslimit.
    \item Memory and storage operations like mload, mstore, sstore, sload.
    \item System operations like call which transfer ether and takes two arguments, receiver address and amount of ether.
    \item Control-flow instructions like goto which encodes conditional jumps across instructions.
\end{enumerate}
Stratified Datalog is a declarative logic language which enables to write facts and rules to infer facts. They then go into the syntax and semantics. A Datalog program consists of one or more rules. A rule consists of a head and a body consisting of literals. The head (sometimes called an atom) is a predicate over zero or more terms. A literal is a predicate or its negation. Datalog variables are written in upper case and constants in lower case. A Datalog program P is stratified if its rules can be partitioned into strata P1...Pn such that if a predicate p occurs in a positive (negative) literal in the body of a rule in Pi, then all rules with p in their heads are in a stratum Pj with j $\leq$ i. Stratification ensures that predicates that appear in negative literals are fully defined in lower strata.

Securify first extracts a set of base facts that hold for every instruction. These base facts constitute a Datalog input that is fed to a Datalog program to infer additional facts about the contract.All program elements that appear in the contract, including instruction labels, variables, fields, string and integer constants are represented as constants in the Datalog program. The base facts take the form of instr(L,Y,X1,...,Xn) where instr is the instruction name, L is the instruction's label, Y is the variable storing the instruction result (if any), and X1,...,Xn are variables given to the instruction as arguments (if any). The base facts of consecutive instructions are expressed by a predicate defined over labels called Follow. For every two label, L1 and L2, whose instructions are consecutive in the CFG, we have the base fact Follow(L1,L2). Using the base facts, Securify computes two kind of semantic facts: flow-dependency predicates which capture instruction dependencies according to the contract's CFG and data-dependency predicates.

The flow predicates they consider are MayFollow and MustFollow, both are defined over pairs of labels and are inferred from the contract's CFG. MayFollow(L1,L2) holds for L1 and L2 if both are in the same basic block and L2 follow L1 or there is path from the basic block of L1 to the basic block of L2. MustFollow(L1,L2) holds if both are in the same basic block and L2 follow L1, or any path to the basic block L2 passes through the basic block of L1. To infer the MayFollow and MustFollow predicates, they use the Follow(L1,L2) input fact which holds if L2 immediately follow L1 in the CFG. The predicate MayFollow is defined with two Datalog rules .The first rule is interpreted as if Follow(L1,L2) hold then the predicate MayFollow(L1,L2) is derived. The second rule is interpreted as if both MayFollow(L1,L3) and Follow(L3,L2) hold then MayFollow(L1,L2) is derived. The inference rules for MustFollow are defined similarly with a special attention to the join points in the CFG.

The data dependency predicates are MayDepOn, Eq, and DetBy. MayDepOn(Y,T) is derived if the value of variable Y depends on the Tag T. Here, the variable T ranges over tags, which can be a contract variable or an instruction. Eq(Y,T) indicates that the values of Y and T are identical. DetBy(Y,T) indicates that a different value of T guarantees that the value of Y changes. There are rule tables and a lot of rule definitions that are good, but I don't want to copy and paste. They'll be good references for when looking at the rules.

\subsection{Section 5: Security Patterns}

This section shows how to express security patterns over semantics facts. They define Securify language for expressing Security patterns. Then to define security properties formally, they provide background on the execution semantics of EVM contracts and formally define properties. They provide a visual example of the syntax of the Securify language. Patterns are interpreted by checking the inferred semantic facts. Quantifiers and connectors are interpreted as usual.Flow and data dependency predicates are interpreted as defined in section 4. 

They then expand on EVM to help give understanding. A contract is a sequence of EVM instructions C = (c0,...,cm). The semantics of a contract is the set of all traces from an initial state. A trace of a contract is a sequence of state-instruction pairs from an initial state and such that the relation is valid according to the EVM execution semantics. A state consists of the storage and memory state, stack state, transaction information, and block information. A property is a relation over sets of traces. A contract satisfies a security property if C is an element of the property. If it isn't we say that it violates the property. They define relations using first-order logic formulas. The formulas are interpreted over the traces and the bitstrings that comprise the user identifiers, offsets , and other arguments or return values of the EVM instructions. They provide a good table for patterns for some of the properties.

They then define seven security properties with respect to the EVM semantics. They provide a lot of detail in the definitions, so I will mainly take notes of the definitions and the requirements. Checking these properties precisely is impossible since EVM is Turing-complete. Instead, for each property we define compliance and violation patterns over the language, which over-approximate the property and its negation. A compliance pattern match implies that the property holds, and a violation pattern match implies that the property's negation holds. If neither pattern is matched, then the property may or may not hold. For each security property they define, they describe the relevance, present the formal definition, and then refine it into a set of compliance and violation patterns.

Ether Liquidity (LQ) occurs because a contract relies on another smart contract to transfer its ether to users. A user can accidentally remove the library contract and freeze the contract's ether. The combination of the contract being able to receive ether from users and the absence of an explicit transfer to the user leads to the issue. Formally, it's defined by requiring that all traces do not change the contract's balance or there exists a trace that decreases the contract's balance.

No writes after calls. An attacker can exploit the combination of two factors. First, a call instruction which upon execution enables the recipient of that call to execute their own code before returning to the contract. Second, the amount transferred by this call depends on a storage value, which is updated after this call. This value is critical as it records the amount of ether that the call's recipient had in the contract and can thus request to receive. This allows the attacker to call the function again before the storage was updated and making the contract believe that the user still had ether in the contract. A property that captures when this attack cannot occur checks that there are no writes to the storage after any call instruction. This is formalized by requiring that for all traces, the storage does not change in the interval that starts just before any call instruction and ends when the trace completes.

Restricted Writes. An attacker can exploit the reliance of a contract on a library that enabled to unconditionally set an owner field to any address. This enables the attacker to take ownership over the contract and steal its ether. It's considered a security property that guarantees that writes to storage are restricted. The property requires that for every storage offset x there is a user that cannot write at offset x of the storage.

Restricted Transfer. This is defined as a property that guarantees that ether transfers cannot be invoked by any user. Violation of this property can detect Ponzi schemes. The compliance pattern requires that for all users, innovations of that call instruction do not transfer ether. Violation patterns check if the call instruction transfers non-zero amount of ether and its execution is independent of the sender or the amount of ether transferred depends on the transaction data while the execution is independent of this data.

Handled Exception. Contract has an issue due to mishandled exceptions. The issue was the return value of a call which indicated if the instruction completed successfully, was not checked. Compliance pattern checks that call instructions are followed by a goto instruction whose condition is determined by the return code of  call. This guarantees that depending on the return code, different execution paths are taken. Violation pattern checks that the call instruction is not followed by a goto instruction which may depend on the return value.

Transaction Ordering Dependency (TOD). An inherent issue in the blockchain model is that there is no guarantee on the execution order of transactions. This has become critical in the context of Initial Coin Offerings. It has been observed that miners exploit this to create their transactions to win the big bonus at a low rate. Section 7 evaluates several version of this property. TOD transfer indicates that the execution of the ether transfer depends on transaction ordering. TOD Amount marks that the amount of ether transferred depends on the transaction ordering. TOD Receiver captures the vulnerability that the recipient of the ether transfer might change, depending on the transaction ordering.

Validated Arguments (VA). Method arguments should be validated before usage, because unexpected arguments may result in insecure contract behaviors. Contracts must check whether all transaction arguments meet their desired ordering. Compliance pattern checks that before storing in the persistent memory a variable that may depend on a method argument, there exists a check of the argument value. Violation pattern identifies sstore instructions that write to memory a method argument without previously checking its value.

There are a few limitations of checking properties through patterns. First, all the violation patterns assume that the violation instructions are part of some terminating execution. Second, the security properties are generic and do not capture contract-specific requirements. Some vulnerabilities are contract specific  and therefore are not captured by the compliance patterns. Third, the patterns don't capture precisely their corresponding properties so it can happen that a contract matches neither the compliance nor the violation pattern. Securify is not limited to checking the security properties described before. It is common for custom patterns to be defined.

An important part of Securify is to pinpoint the instructions that lead to violations of security properties as this enables developers to fix the code.There are patterns that enable the error localization. They are called instruction patterns and we call the other patterns contract patterns. If a violation pattern is a n instruction pattern and it is matched by some instruction, then Securify can highlight this instruction as a violation. Similar for compliances and warnings. Contract patterns are patterns that aren't instruction patterns. It is difficult for them to pinpoint a single instruction responsible for its violation. The ether liquidity violation pattern is an example of a contract pattern.

\subsection{Section 6: Implementation}

The decompiler transforms the EVM bytecode provided as input into the corresponding assembly instructions. It converts the EVM instructions into an SSA form. The SSA instructions are identical to the EVM instruction set except they exclude stack operations. Securify employs three optimizations over the control-flow graph:
\begin{enumerate}
    \item Unused instructions, which eliminates any instructions whose results are not used. On average, this reduces the contract's instructions by 44\% and improves scalability and precision of the analysis.
    \item Partial evaluation which propagates constant values along computations. This step improves the precision of storage and memory analysis. Partial evaluation resolves over 70\% of the offsets that appear in storage/memory instructions.
    \item Method inlining which improves the precision of the static analysis by making it context sensitive.
\end{enumerate}
Securify derives semantic facts using inference rules specified in stratified Datalog, using the Souffle Datalog solver to efficiently compute a fixed-point of all facts. To check the security patterns, Securify iterates over the instructions to handle the all and some quantifiers in the patterns. Then to check for inferred facts, it directly queries the fixed=point computed by the Datalog solver. If a violation pattern is matched, Securify reports which instructions are identified as vulnerable to provide error-localization for users. If no pattern is matched, Securify reports a warning to indicate than an instruction may or may not be vulnerable.

\subsection{Section 7: Evaluation}

To evaluate Securify, they did the following experiments:
\begin{enumerate}
    \item Evaluated Securify's effectiveness in proving the correctness of and discovering violations in real-world contracts.
    \item Manually inspected Securify's results on smart contracts whose source code had been uploaded to Securify's public interface.
    \item Compared Securify to Oyente and Mythril, two smart contract checkers based on symbolic execution.
    \item Measured the success of Securify's decompiler in resolving memory and storage offsets.
    \item Measured Securify's time and memory consumption.
\end{enumerate}
They used two data sets, the first being EVM dataset which was 24,594 smart contracts obtained by parsing create transactions using the parity client. The second dataset, Solidity dataset, consists of 100 smart contracts written in Solidity that were uploaded to Securify's public interface. They selected the first 100 contracts in alphabetical order uploaded in 2018. They restricted the selection to contracts with up to 200 lines of Solidity code. 

To evaluate Securify's effectiveness in proving security properties and finding violation in real-world contracts, they ran Securify on all smart contracts in the EVM dataset and measured the fraction of violation, warnings, and compliances reported. For the no writes after calls property, 6.5\% of the call instructions violate the property with 90.9\% proved to be compliant and the remaining 2.6\% are reported as warnings. On average, Securify proves that 55.5\% of the relevant instructions are safe, 29.3\% are definite violations, and 15.2\% warnings. The results indicate that Securify's compliance and violation patterns are expressive enough to prove and disprove relevant security properties. It could also be refined by extending it with addition patterns.


For the manual inspection, they ran Securify on the contracts in the Solidity dataset. They then manually classified each reported warning as a true or false warning. They also inspected and confirmed the correctness of all reported violations and compliances. There were a higher number of security issues discovered in this dataset which is believed to be because that they are recent contracts that in development stage. They had a hard time to prove/disprove things like restricted transfer property and the three transaction ordering dependence properties. Things like no writes after calls and handled exception were precise. 

When comparing Securify to symbolic security checkers, they used Oyente and Mythril. Since Oyente and Mythril may report false positive, they treated all bugs listed by them as warnings as they must be classified by the user. Oyente and Mythril also don't report definite violations. Since they explore a subset of all contract's behaviors, they may fail to report certain vulnerabilities and they report these as unreported vulnerabilities. They observed for all properties except reentrancy they miss to report some vulnerabilities. Oyente fails to report 72.9\% of TOD violations and Mythril fails to report 65.6\% of the restricted transfer violations. 

They also report on Securify's partial evaluation optimization for resolving memory and storage offsets. On average across all four instructions, partial evaluation correctly resolves 72.6\% of the offsets. Memory offsets are more often resolved than storage offsets. Securify terminates for all contracts and takes on average 30 seconds per contract to check all compliance and violation patterns. Oyente and Mythril have similar times with their default settings that don't provide full coverage. The memory consumption of Securify is determined by the size of the fixed point analysis. In 95\% of cases ,the consumption was below 10MB and the rest was below 1GB.

\section{References}
\printbibliography

\end{document}
